/**
 * @jest-environment node
 */
import { StatusCodes } from "http-status-codes";
import request from "supertest";
import { faker } from "@faker-js/faker";
import app from "../../server";
import VulnerabilityModel, { IVulnerability } from "../../app/models/vulnerability.model";
import Project, { IProject } from "../../app/models/project.model";
import User from "../../app/models/user.model";
import { disconnectDB } from "../../app/config/db";
import { generateAuthToken } from "../../app/utils/generateHash";
import mongoose from "mongoose";

let token = "";
let projectId = "";
let testUser: any;
let testProject: IProject = {} as IProject;;
let createdVulnerability: IVulnerability;
let updateTarget: IVulnerability;
let deleteTarget: IVulnerability;

describe("ðŸ§© VULNERABILITY API TESTING", () => {
  beforeAll(async () => {
    // create a test user
    testUser = await User.create({
      name: faker.name.fullName(),
      email: faker.internet.email(),
      password: faker.internet.password(),
      role: "member",
    });

    token = await generateAuthToken({
      id: testUser.id,
      email: testUser.email,
    });

    // create a test project
    testProject = new Project({
        title: faker.vehicle.vehicle(),
        desc: faker.vehicle.manufacturer(),
        projectType: "web",
        client: new mongoose.Types.ObjectId(),
        manager: new mongoose.Types.ObjectId(),
        members: [new mongoose.Types.ObjectId()],
        appFile: {
          name: "mock.apk",
          url: faker.internet.url(),
          size: 2048,
          uploadedAt: new Date(),
        },
      });
      let savedProj = await testProject.save();
     projectId = testProject._id?.toString() || '';
    // create a few dummy vulnerabilities
    for (let i = 0; i < 3; i++) {
      const vuln = await VulnerabilityModel.create({
        title: faker.lorem.words(3),
        type: "App Testing",
        desc: faker.lorem.sentence(),
        stepToReproduce: "Steps to reproduce",
        severity: "medium",
        reportedBy: testUser._id,
        projectId: testProject._id,
      });

      if (i === 1) updateTarget = vuln;
      if (i === 2) deleteTarget = vuln;
    }
  }, 20000);

  // âœ… Create Vulnerability
  it("POST /api/vulnerability â†’ should create a new vulnerability", async () => {
    const res = await request(app)
      .post(`/api/vulnerability/${projectId}`)
      .send({
        title: "SQL Injection",
        vulnerabilityType: "Web Application",
        desc: "SQL Injection vulnerability found in login form",
        stepToReproduce: "Submit `' OR 1=1--` in username field",
        proofOfConcept: ["http://example.com/poc1", "http://example.com/poc2"],
        severity: "high",
        status: "open",
        reportedBy: testUser._id,
        projectId: testProject._id,
      })
      .set("Authorization", `Bearer ${token}`);

    expect(res.status).toBe(StatusCodes.CREATED);
    expect(res.body).toHaveProperty("data");
    createdVulnerability = res.body.data;
  }, 10000);

  // âœ… Get Vulnerabilities
  it("GET /api/vulnerability â†’ should fetch all vulnerabilities", async () => {
    const res = await request(app)
    .get(`/api/vulnerability/${projectId}`)
    .set("Authorization", `Bearer ${token}`);
    expect(res.status).toBe(StatusCodes.OK);
    expect(res.body).toHaveProperty("data");
    expect(Array.isArray(res.body.data)).toBe(true);
  }, 10000);

  // âœ… Update Vulnerability (general update)
  it("PUT /api/vulnerability/:id â†’ should update vulnerability fields", async () => {
    const res = await request(app)
      .put(`/api/vulnerability/${updateTarget._id?.toString()}`)
      .send({ title: "Updated Title", severity: "critical" })
      .set("Authorization", `Bearer ${token}`);

    expect(res.status).toBe(StatusCodes.OK);
    expect(res.body.data.title).toBe("Updated Title");
  }, 10000);

  // âœ… Update Vulnerability status
  it("PATCH /api/vulnerability/:id/status â†’ should update status only", async () => {
    const res = await request(app)
      .patch(`/api/vulnerability/${updateTarget._id?.toString()}/update-status`)
      .send({ status: "resolved" })
      .set("Authorization", `Bearer ${token}`);

    expect(res.status).toBe(StatusCodes.OK);
    expect(res.body.data.status).toBe("resolved");
  }, 10000);

  // âœ… Update Vulnerability severity
  it("PATCH /api/vulnerability/:id/severity â†’ should update severity only", async () => {
    const res = await request(app)
      .patch(`/api/vulnerability/${updateTarget._id?.toString()}/update-severity`)
      .send({ severity: "critical" })
      .set("Authorization", `Bearer ${token}`);

    expect(res.status).toBe(StatusCodes.OK);
    expect(res.body.data.severity).toBe("critical");
  }, 10000);

  // âœ… Delete Vulnerability
  it("DELETE /api/vulnerability/:id â†’ should delete vulnerability by ID", async () => {
    const res = await request(app)
      .delete(`/api/vulnerability/${deleteTarget._id?.toString()}`)
      .set("Authorization", `Bearer ${token}`);

    expect(res.status).toBe(StatusCodes.OK);
    expect(res.body).toHaveProperty("message");
  }, 10000);

  // âŒ Negative: Try deleting a non-existing vulnerability
  it("DELETE /api/vulnerability/:id â†’ should return 404 if not found", async () => {
    const res = await request(app)
      .delete(`/api/vulnerability/656565656565656565656565`)
      .set("Authorization", `Bearer ${token}`);

    expect(res.status).toBe(StatusCodes.NOT_FOUND);
  }, 10000);

  // âŒ Negative: Try creating vulnerability with missing required fields
  it("POST /api/vulnerability â†’ should fail with missing required fields", async () => {
    const res = await request(app)
      .post(`/api/vulnerability/${projectId}`)
      .send({
        desc: "Missing title, type, etc.",
      })
      .set("Authorization", `Bearer ${token}`);

    expect(res.status).toBe(StatusCodes.BAD_REQUEST);
  }, 10000);

  afterAll(async () => {
    await VulnerabilityModel.deleteMany({});
    await Project.deleteMany({});
    await User.deleteMany({});
    await disconnectDB();
  });
});

// controllers/vulnerability.controller.ts
import { Request, Response, NextFunction } from "express";
import httpStatusCode from "http-status-codes";
import VulnerabilityModel from "../models/vulnerability.model";
import ErrorHandler from "../utils/errorHandler";
import { asyncHandler } from "../utils/asyncHandler";

// ✅ GET ALL Vulnerabilities (with filters)
export const getVulnerabilities = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {
    const { projectId } = req.params;
    const { reportedBy, severity, status, type } = req.query;

    const query: any = {};

    if (projectId) query.projectId = projectId;
    if (reportedBy) query.reportedBy = reportedBy;
    if (severity) query.severity = severity;
    if (status) query.status = status;
    if (type) query.type = type;

    const vulnerabilities = await VulnerabilityModel.find(query)
        .populate("reportedBy", "name email")
        .populate("verifiedBy", "name email")
        .populate("projectId", "title");

    return res.status(httpStatusCode.OK).json({
        success: true,
        message: "Vulnerabilities fetched successfully.",
        data: vulnerabilities,
    });
});

// ✅ CREATE Vulnerability
export const createVulnerability = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {
    const {
        title,
        type,
        desc,
        stepToReproduce,
        severity,
        impact,
        recommendation,
        affectedEndpoint,
        proofOfConcept,
        attachments,
        tags,
        reportedBy,
        verifiedBy,
        projectId,
        resolvedAt,
    } = req.body;


    const newVulnerability = await VulnerabilityModel.create({
        title,
        type,
        desc,
        stepToReproduce,
        severity,
        impact,
        recommendation,
        affectedEndpoint,
        proofOfConcept,
        attachments,
        tags,
        reportedBy,
        verifiedBy,
        projectId,
        resolvedAt,
    });

    return res.status(httpStatusCode.CREATED).json({
        success: true,
        message: "Vulnerability reported successfully.",
        data: newVulnerability,
    });
});

// ✅ UPDATE Vulnerability (any field)
export const updateVulnerability = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {
    const { id } = req.params;
    const updates = req.body;

    const updated = await VulnerabilityModel.findByIdAndUpdate(id, updates, { new: true });

    if (!updated) {
        throw new ErrorHandler({
            statusCode: httpStatusCode.NOT_FOUND,
            errorMessage: "Vulnerability not found.",
        });
    }

    return res.status(httpStatusCode.OK).json({
        success: true,
        message: "Vulnerability updated successfully.",
        data: updated,
    });
});

// ✅ UPDATE only Status
export const updateVulnerabilityStatus = async (req: Request, res: Response, next: NextFunction) => {
    const { id } = req.params;
    const { status } = req.body;

    if (!status) {
        throw new ErrorHandler({
            statusCode: httpStatusCode.BAD_REQUEST,
            errorMessage: "Status field is required.",
        });
    }

    const updated = await VulnerabilityModel.findByIdAndUpdate(id, { status }, { new: true });

    if (!updated) {
        throw new ErrorHandler({
            statusCode: httpStatusCode.NOT_FOUND,
            errorMessage: "Vulnerability not found.",
        });
    }

    return res.status(httpStatusCode.OK).json({
        success: true,
        message: `Status updated to '${status}'.`,
        data: updated,
    });
};

// ✅ UPDATE only Severity
export const updateVulnerabilitySeverity = async (req: Request, res: Response, next: NextFunction) => {
    const { id } = req.params;
    const { severity } = req.body;

    if (!severity) {
        throw new ErrorHandler({
            statusCode: httpStatusCode.BAD_REQUEST,
            errorMessage: "Severity field is required.",
        });
    }

    const updated = await VulnerabilityModel.findByIdAndUpdate(id, { severity }, { new: true });

    if (!updated) {
        throw new ErrorHandler({
            statusCode: httpStatusCode.NOT_FOUND,
            errorMessage: "Vulnerability not found.",
        });
    }

    return res.status(httpStatusCode.OK).json({
        success: true,
        message: `Severity updated to '${severity}'.`,
        data: updated,
    });
};

// ✅ DELETE Vulnerability
export const deleteVulnerability = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {
    const { id } = req.params;

    const deleted = await VulnerabilityModel.findByIdAndDelete(id);

    if (!deleted) {
        throw new ErrorHandler({
            statusCode: httpStatusCode.NOT_FOUND,
            errorMessage: "Vulnerability not found.",
        });
    }

    return res.status(httpStatusCode.OK).json({
        success: true,
        message: "Vulnerability deleted successfully.",
    });
});
